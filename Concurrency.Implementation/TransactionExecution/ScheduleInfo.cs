using Utilities;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Collections.Generic;
using System;

namespace Concurrency.Implementation.TransactionExecution
{
    public class ScheduleInfo
    {
        public Dictionary<int, ScheduleNode> detNodes;     // node ID: batch ID (local bid generated by local coordinators)
        public Dictionary<int, ScheduleNode> nonDetNodes;  // node ID: ACT tid

        // in single-silo deployment, ACT tid is generated by coordinators in the silo
        // in multi-silo deployment, ACT tid is generated by global coordinators, since it is unknown if the ACT is a local or global transaction
        public Dictionary<int, int> nonDetTidToNodeID;
        public Dictionary<int, HashSet<int>> nonDetNodeIDToTxnSet;
        
        public ScheduleInfo()
        {
            detNodes = new Dictionary<int, ScheduleNode>();
            nonDetNodes = new Dictionary<int, ScheduleNode>();
            nonDetNodeIDToTxnSet = new Dictionary<int, HashSet<int>>();
            nonDetTidToNodeID = new Dictionary<int, int>();

            var node = new ScheduleNode(-1, true);
            node.nextNodeCanExecute.SetResult(true);
            detNodes.Add(-1, node);
        }

        public void CheckGC()
        {
            if (detNodes.Count > 2) Console.WriteLine($"ScheduleInfo: detNodes.Count = {detNodes.Count}");
            if (nonDetTidToNodeID.Count != 0) Console.WriteLine($"ScheduleInfo: nonDetTidToNodeID.Count = {nonDetTidToNodeID.Count}");

            if (nonDetNodes.Count > 1) Console.WriteLine($"ScheduleInfo: nonDetNodes.Count = {nonDetNodes.Count}");
            if (nonDetNodeIDToTxnSet.Count > 1) Console.WriteLine($"ScheduleInfo: nonDetNodeIDToTxnSet.Count = {nonDetNodeIDToTxnSet.Count}");
        }

        private ScheduleNode FindTail()
        {
            var node = detNodes[-1];
            while (node.next != null) node = node.next;
            return node;
        }

        public ScheduleNode InsertNonDetTransaction(int tid)
        {
            Debug.Assert(nonDetTidToNodeID.ContainsKey(tid) == false);
            var tail = FindTail();
            if (tail.isDet)
            {
                var node = new ScheduleNode(tid, false);
                var txnSet = new HashSet<int>();
                txnSet.Add(tid);

                nonDetNodeIDToTxnSet.Add(tid, txnSet);
                nonDetNodes.Add(tid, node);
                tail.next = node;
                node.prev = tail;
                tail = node;
            }
            else
            {
                //Join the non-det tail, replace the promise
                if (tail.nextNodeCanExecute.Task.IsCompleted) tail.nextNodeCanExecute = new TaskCompletionSource<bool>();
                nonDetNodeIDToTxnSet[tail.id].Add(tid);
            }
            
            nonDetTidToNodeID.Add(tid, tail.id);
            return tail.prev;
        }

        public void InsertDetBatch(LocalSubBatch schedule)
        {
            ScheduleNode node;
            if (!detNodes.ContainsKey(schedule.bid))
            {
                node = new ScheduleNode(schedule.bid, true);
                detNodes.Add(schedule.bid, node);
            }
            else node = detNodes[schedule.bid];

            if (detNodes.ContainsKey(schedule.lastBid))
            {
                var prevNode = detNodes[schedule.lastBid];
                if (prevNode.next == null)
                {
                    prevNode.next = node;
                    node.prev = prevNode;
                }
                else
                {
                    Debug.Assert(prevNode.next.isDet == false && prevNode.next.next == null);
                    prevNode.next.next = node;
                    node.prev = prevNode.next;
                }
            }
            else
            {
                // last node is already deleted because it's committed
                if (schedule.highestCommittedBid >= schedule.lastBid)
                {
                    var prevNode = detNodes[-1];
                    if (prevNode.next == null)
                    {
                        prevNode.next = node;
                        node.prev = prevNode;
                    }
                    else
                    {
                        Debug.Assert(prevNode.next.isDet == false && prevNode.next.next == null);
                        prevNode.next.next = node;
                        node.prev = prevNode.next;
                    }
                }
                else   // last node hasn't arrived yet
                {
                    var prevNode = new ScheduleNode(schedule.lastBid, true);
                    detNodes.Add(schedule.lastBid, prevNode);
                    prevNode.next = node;
                    node.prev = prevNode;
                    Debug.Assert(prevNode.prev == null);
                }
            }
        }

        public ScheduleNode GetDependingNode(int id, bool isDet)
        {
            if (isDet) return detNodes[id].prev;
            else return nonDetNodes[nonDetTidToNodeID[id]].prev;
        }

        public Tuple<int, int, bool> GetBeforeAfter(int tid)   // <max, min, isConsecutive>
        {
            var node = nonDetNodes[nonDetTidToNodeID[tid]];
            var prevNode = node.prev;
            var maxBeforeBid = prevNode.id;

            int minAfterBid;
            if (node.next != null)
            {
                Debug.Assert(node.next.isDet);
                minAfterBid = node.next.id;
                return new Tuple<int, int, bool>(maxBeforeBid, minAfterBid, true);
            }

            minAfterBid = -1;
            foreach (var detNode in detNodes)
            {
                if (detNode.Key > maxBeforeBid)
                {
                    if (minAfterBid == -1) minAfterBid = detNode.Key;
                    else minAfterBid = Math.Min(minAfterBid, detNode.Key);
                }
            }

            return new Tuple<int, int, bool>(maxBeforeBid, minAfterBid, false);    // both may be -1
        }

        public void CompleteDetBatch(int id)
        {
            detNodes[id].nextNodeCanExecute.SetResult(true);
        }

        public void CommitNonDetTxn(int tid)   // when commit/abort a non-det txn
        {
            if (!nonDetTidToNodeID.ContainsKey(tid)) return;
            var nodeId = nonDetTidToNodeID[tid];
            nonDetTidToNodeID.Remove(tid);
            var txnSet = nonDetNodeIDToTxnSet[nodeId];

            txnSet.Remove(tid);
            if (txnSet.Count == 0) nonDetNodes[nodeId].nextNodeCanExecute.SetResult(true);
        }
    }

    public class ScheduleNode
    {
        public int id;
        public bool isDet;
        public TaskCompletionSource<bool> nextNodeCanExecute;
        public ScheduleNode prev;
        public ScheduleNode next;

        public ScheduleNode(int id, bool isDet)
        {
            this.id = id;
            this.isDet = isDet;
            nextNodeCanExecute = new TaskCompletionSource<bool>();
        }
    }
}